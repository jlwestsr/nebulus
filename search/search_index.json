{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Nebulus","text":"<p>Welcome to the documentation for Nebulus.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Please refer to the README for installation and usage instructions.</p>"},{"location":"#features","title":"Features","text":""},{"location":"ROADMAP/","title":"Feature Roadmap","text":""},{"location":"ROADMAP/#1-enhanced-agent-capabilities-mcp-server","title":"1. Enhanced Agent Capabilities (MCP Server)","text":"<p>Currently, the agent is read-only. To make it a true \"Black Box\" engineer, we should expand its toolset. - [ ] File Write Support: Add <code>write_file</code> and <code>edit_file</code> tools to allow the agent to modify code directly. - [ ] Web Scraper: Add a <code>scrape_url</code> tool (using <code>beautifulsoup</code> or <code>newspaper3k</code>) to fetch full page content, enabling deep research beyond search snippets. - [ ] Safe Terminal Access: Add a <code>run_command</code> tool (allowlisted commands only, e.g., <code>ls</code>, <code>grep</code>, <code>pytest</code>) to let the agent explore and test the environment.</p>"},{"location":"ROADMAP/#2-operational-stability","title":"2. Operational Stability","text":"<ul> <li>[ ] Automated Backups: Create a script/cron job to snapshot <code>ollama_data</code>, <code>chroma_data</code>, and <code>webui_data</code> volumes.</li> <li>[ ] Log Management: Add Dozzle to the Docker stack for real-time, web-based log monitoring of all containers.</li> <li>[ ] Health Checks: Implement a status dashboard (or just a healthcheck script) to verify all services are talking to each other correctly.</li> </ul>"},{"location":"ROADMAP/#3-knowledge-rag","title":"3. Knowledge &amp; RAG","text":"<ul> <li>[ ] Codebase Indexing: Implement a tool like <code>grep</code> or <code>ripgrep</code> in MCP to allow the agent to search the codebase semantically/regex-wise, complementing the vector store.</li> <li>[ ] Document Parsers: Add support for parsing PDF/Docx files within the MCP server for direct analysis.</li> </ul>"},{"location":"ROADMAP/#4-model-performance","title":"4. Model &amp; Performance","text":"<ul> <li>[ ] Vision Support: Configure Llava or similar vision-capable models in Ollama by default.</li> <li>[ ] Fine-tuning Pipeline: A script to prepare local data for easy Lora fine-tuning (future scope).</li> </ul>"},{"location":"feature_template/","title":"Feature: [Feature Name]","text":""},{"location":"feature_template/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/[feature-name]</code></p> <p>Briefly describe the feature, the problem it solves, and why it is being built.</p>"},{"location":"feature_template/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [ ] Requirement 1 - [ ] Requirement 2</p>"},{"location":"feature_template/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: List modified/created files (e.g., <code>src/module.py</code>).</li> <li>Dependencies: List new packages (e.g., <code>rich</code>).</li> <li>Data: Database changes or new assets.</li> </ul>"},{"location":"feature_template/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [ ] Script/Test: <code>pytest tests/test_feature.py</code> - [ ] Logic Verified: [Describe what is tested]</p> <p>Manual Verification: - [ ] Step 1: Run <code>forge --flag</code> - [ ] Step 2: Verify output in <code>dist/</code></p>"},{"location":"feature_template/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [ ] Branch: Created <code>feat/...</code> branch? - [ ] Work: Implemented changes? - [ ] Test: All tests pass (<code>pytest</code>)? - [ ] Doc: Updated <code>README.md</code> and <code>walkthrough.md</code>? - [ ] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/01_file_write_support/","title":"Feature: File Write Support","text":""},{"location":"features/01_file_write_support/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/file-write-support</code></p> <p>Enable the MCP agent to modify the codebase directly by adding file writing capabilities. This transforms the agent from a read-only advisor to an active engineer capable of implementing changes.</p>"},{"location":"features/01_file_write_support/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>write_file</code> tool: Accepts <code>path</code> and <code>content</code>. Overwrites or creates new files. - [x] Implement <code>edit_file</code> tool: Accepts <code>path</code>, <code>target_text</code>, and <code>replacement_text</code> for surgical edits. - [x] Security: Ensure all paths are validated to be strictly within <code>/workspace</code>. - [x] Security: Prevent traversal attacks (e.g., <code>../</code>).</p>"},{"location":"features/01_file_write_support/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Modify <code>mcp_server/server.py</code> to add new <code>@mcp.tool()</code> functions.</li> <li>Dependencies: No new packages required (standard <code>os</code> and <code>io</code>).</li> <li>Data: No database changes.</li> </ul>"},{"location":"features/01_file_write_support/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: Create <code>tests/test_file_ops.py</code> to test <code>write_file</code> and <code>edit_file</code>. - [x] Logic Verified: Verify file creation, content overwriting, and correct string replacement.</p> <p>Manual Verification: - [x] Step 1: Connect Open WebUI to MCP. - [x] Step 2: Ask agent to \"Create a file named hello.txt with content 'Hello World'\". - [x] Step 3: Verify file existence in <code>/workspace</code>.</p>"},{"location":"features/01_file_write_support/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/file-write-support</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass (<code>pytest</code>)? - [x] Doc: Updated <code>README.md</code> and <code>walkthrough.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/02_safe_terminal_access/","title":"Feature: Safe Terminal Access","text":""},{"location":"features/02_safe_terminal_access/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/safe-terminal</code></p> <p>Give the agent a restricted <code>run_command</code> tool. This allows it to explore the environment (<code>ls</code>, <code>find</code>), check statuses (<code>git status</code>), and run tests (<code>pytest</code>), but prevents destructive actions.</p>"},{"location":"features/02_safe_terminal_access/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>run_command</code> tool: Accepts <code>command</code> string. - [x] Allowlist: Only execute commands starting with allowed binaries (e.g., <code>ls</code>, <code>grep</code>, <code>cat</code>, <code>find</code>, <code>pytest</code>, <code>git</code>, <code>echo</code>). - [x] Blocklist: Explicitly reject <code>rm</code>, <code>mv</code>, <code>chmod</code>, <code>chown</code>, <code>sudo</code>, <code>&gt;</code>. - [x] Timeout: Kill commands taking longer than X seconds.</p>"},{"location":"features/02_safe_terminal_access/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Modify <code>mcp_server/server.py</code>.</li> <li>Dependencies: <code>subprocess</code> (standard lib).</li> <li>Data: None.</li> </ul>"},{"location":"features/02_safe_terminal_access/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: <code>test_terminal.py</code>. - [x] Logic Verified: Test allowed command returns output. Test blocked command returns permission error.</p> <p>Manual Verification: - [x] Step 1: Ask agent to \"List files in current directory\". -&gt; Success. - [x] Step 2: Ask agent to \"Delete all files\". -&gt; Failure/Refusal.</p>"},{"location":"features/02_safe_terminal_access/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/safe-terminal</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass (<code>pytest</code>)? - [x] Doc: Updated <code>README.md</code> and <code>walkthrough.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/03_web_scraper/","title":"Feature: Web Scraper","text":""},{"location":"features/03_web_scraper/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/web-scraper</code></p> <p>Add a <code>scrape_url</code> tool to the MCP server. While the search tool finds links, this tool allows the agent to read the full content of a page, enabling deep research and documentation analysis.</p>"},{"location":"features/03_web_scraper/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>scrape_url</code> tool: Accepts <code>url</code>. - [x] Parsing: Extract main text content from HTML, removing ads/nav (using <code>beautifulsoup4</code> or <code>newspaper3k</code>). - [x] Formatting: Return clean Markdown. - [x] Error Handling: Gracefully handle 404s, timeouts, and unparseable content.</p>"},{"location":"features/03_web_scraper/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Modify <code>mcp_server/server.py</code>.</li> <li>Dependencies: Add <code>beautifulsoup4</code> and <code>requests</code> (or <code>httpx</code>) to <code>mcp_server/requirements.txt</code>.</li> <li>Data: None.</li> </ul>"},{"location":"features/03_web_scraper/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: <code>test_scraper.py</code> checking extraction against a known static HTML page. - [x] Logic Verified: Ensure HTML tags are stripped and text is readable.</p> <p>Manual Verification: - [x] Step 1: Ask agent to \"Read https://example.com\". - [x] Step 2: Verify it returns the full text content of the page.</p>"},{"location":"features/03_web_scraper/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/web-scraper</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass (<code>pytest</code>)? - [x] Doc: Updated <code>README.md</code> and <code>walkthrough.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/04_codebase_indexing/","title":"Feature: Codebase Indexing","text":""},{"location":"features/04_codebase_indexing/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/codebase-indexing</code></p> <p>Empower the agent to search the codebase using regular expressions and semantic search logic. The current vector store provides semantic chunk retrieval, but exact keyword search (<code>grep</code>) is often more precise for engineering tasks.</p>"},{"location":"features/04_codebase_indexing/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>search_code</code> tool: Accepts <code>query</code> and <code>path</code>. - [x] Engine: Use <code>grep</code> or <code>ripgrep</code> (if installed) via subprocess. - [x] Output: Return file paths and matching lines with context. - [x] Integration: Ensure it respects <code>.gitignore</code> to avoid searching artifacts/dependencies.</p>"},{"location":"features/04_codebase_indexing/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Modify <code>mcp_server/server.py</code>.</li> <li>Dependencies: None (uses system <code>grep</code>) or <code>ripgrep</code> binary in Dockerfile.</li> <li>Data: None.</li> </ul>"},{"location":"features/04_codebase_indexing/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: <code>test_search.py</code>. Search for unique string in a test file.</p> <p>Manual Verification: - [x] Step 1: Ask agent \"Find all TODOs in the codebase\". - [x] Step 2: Verify it returns a list of files and lines containing \"TODO\".</p>"},{"location":"features/04_codebase_indexing/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/codebase-indexing</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass? - [x] Doc: Updated <code>README.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/05_log_management/","title":"Feature: Log Management (Dozzle)","text":""},{"location":"features/05_log_management/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/log-management</code></p> <p>Integrate Dozzle into the Docker Compose stack. This provides a lightweight, real-time web interface for monitoring logs from all containers, which is essential for debugging and monitoring long-running agent tasks.</p>"},{"location":"features/05_log_management/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Add <code>dozzle</code> service to <code>docker-compose.yml</code>. - [x] Configuration: Mount <code>/var/run/docker.sock</code>. - [x] Access: Expose on port <code>8888</code> (or similar). - [x] Security: Limit access (basic auth if possible, or note for local use only).</p>"},{"location":"features/05_log_management/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Update <code>docker-compose.yml</code>.</li> <li>Dependencies: <code>amir20/dozzle:latest</code> image.</li> <li>Data: None.</li> </ul>"},{"location":"features/05_log_management/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Docker Healtcheck: Verify container starts.</p> <p>Manual Verification: - [x] Step 1: Run <code>docker compose up -d</code>. - [x] Step 2: Open <code>http://localhost:8888</code>. - [x] Step 3: Verify logs from <code>blackbox-ollama</code> and <code>blackbox-mcp</code> are visible.</p>"},{"location":"features/05_log_management/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/log-management</code> branch? - [x] Work: Implemented changes? - [x] Test: Verified UI? - [x] Doc: Updated <code>README.md</code> with URL? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/06_health_checks/","title":"Feature: Health Checks","text":""},{"location":"features/06_health_checks/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/health-checks</code></p> <p>Implement a comprehensive health check script. As the system grows with multiple services (Ollama, Chroma, WebUI, MCP), knowing the precise status of each and their connectivity is vital for debugging.</p>"},{"location":"features/06_health_checks/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>scripts/health.sh</code>. - [x] Ollama: Check <code>/api/tags</code> to verify it's up and models are loaded. - [x] ChromaDB: Check <code>/api/v2/heartbeat</code> (Updated from v1). - [x] MCP: Check <code>/health</code> or SSE connection (might need a new endpoint in server.py). - [x] WebUI: Check HTTP 200 on root.</p>"},{"location":"features/06_health_checks/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Create <code>scripts/health.sh</code>. Modify <code>mcp_server/server.py</code> to add a <code>/health</code> GET endpoint.</li> <li>Dependencies: <code>curl</code>.</li> <li>Data: None.</li> </ul>"},{"location":"features/06_health_checks/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: Run <code>scripts/health.sh</code> in CI/setup.</p> <p>Manual Verification: - [x] Step 1: Run <code>./scripts/health.sh</code>. - [x] Step 2: Confirm it reports \"OK\" for all services when running. - [x] Step 3: Stop a service and confirm it reports \"FAIL\".</p>"},{"location":"features/06_health_checks/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/health-checks</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass? - [x] Doc: Updated <code>README.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/07_automated_backups/","title":"Feature: Automated Backups","text":""},{"location":"features/07_automated_backups/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/automated-backups</code></p> <p>Create a robust backup solution for the persistent data in Ollama, ChromaDB, and Open WebUI. This ensures that user chats, downloaded models, and vector embeddings are safe.</p>"},{"location":"features/07_automated_backups/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>scripts/backup.sh</code>: usage <code>./scripts/backup.sh [output_dir]</code>. - [x] Strategy: Use a temporary alpine container to mount the volumes and create a compressed tarball (<code>.tar.gz</code>). - [x] Volumes: Backup <code>ollama_data</code>, <code>chroma_data</code>, <code>webui_data</code>. - [x] Retention: (Optional) Simple rotation to keep last N backups.</p>"},{"location":"features/07_automated_backups/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Create <code>scripts/backup.sh</code> and <code>scripts/restore.sh</code>.</li> <li>Dependencies: <code>docker</code> (CLI).</li> <li>Data: New backup artifacts in <code>backups/</code> directory.</li> </ul>"},{"location":"features/07_automated_backups/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: <code>test_backup_restore.sh</code>. Run backup, delete volume, run restore, verify data exists.</p> <p>Manual Verification: - [x] Step 1: Run <code>scripts/backup.sh</code>. - [x] Step 2: Stop containers and <code>docker volume rm ...</code>. - [x] Step 3: Run <code>scripts/restore.sh</code>. - [x] Step 4: Start containers and verify chat history/models are present.</p>"},{"location":"features/07_automated_backups/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/automated-backups</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass? - [x] Doc: Updated <code>README.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/08_document_parsers/","title":"Feature: Document Parsers","text":""},{"location":"features/08_document_parsers/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/document-parsers</code></p> <p>Expand the MCP server's file reading capabilities to support binary document formats like PDF and DOCX. This allows the agent to ingest requirements, research papers, and legacy documentation directly.</p>"},{"location":"features/08_document_parsers/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>read_pdf</code> tool. - [x] Implement <code>read_docx</code> tool. - [x] Library: Use <code>pypdf</code> (or <code>pdfminer.six</code>) and <code>python-docx</code>. - [x] Output: Return extracted text content.</p>"},{"location":"features/08_document_parsers/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Modify <code>mcp_server/server.py</code>.</li> <li>Dependencies: Add <code>pypdf</code>, <code>python-docx</code> to <code>mcp_server/requirements.txt</code>.</li> <li>Data: None.</li> </ul>"},{"location":"features/08_document_parsers/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: <code>test_parsers.py</code>. Test against sample PDF/DOCX files.</p> <p>Manual Verification: - [x] Step 1: Upload a PDF to the workspace. - [x] Step 2: Ask agent to \"Summarize resume.pdf\". - [x] Step 3: Verify it reads and understands the content.</p>"},{"location":"features/08_document_parsers/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/document-parsers</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass? - [x] Doc: Updated <code>README.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/09_vision_support/","title":"Feature: Vision Support","text":""},{"location":"features/09_vision_support/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/vision-support</code></p> <p>Enable the system to process images by integrating a vision-language model (VLM) like <code>llava</code>. This allows users to upload screenshots, diagrams, or mockups for the AI to analyze.</p>"},{"location":"features/09_vision_support/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Model: Add <code>llava:latest</code> (or <code>llama3.2-vision</code> if available) to the default model list. - [x] Config: Ensure Open WebUI is configured to use this model for image inputs. - [x] Pull: Update <code>ansible/setup.yml</code> to pull the vision model.</p>"},{"location":"features/09_vision_support/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Update <code>ansible/setup.yml</code> and <code>README.md</code>.</li> <li>Dependencies: None.</li> <li>Data: New model weight (large download).</li> </ul>"},{"location":"features/09_vision_support/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [ ] Script/Test: <code>ollama run llava \"describe this image\"</code>.</p> <p>Manual Verification: - [ ] Step 1: Open WebUI. - [ ] Step 2: Upload an image. - [ ] Step 3: Ask \"What is in this image?\". - [ ] Step 4: Verify accurate description.</p>"},{"location":"features/09_vision_support/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/vision-support</code> branch? - [x] Work: Implemented changes? - [x] Test: Verified manually? - [x] Doc: Updated <code>README.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/10_fine_tuning_pipeline/","title":"Feature: Fine-tuning Pipeline","text":""},{"location":"features/10_fine_tuning_pipeline/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/finetune-pipeline</code></p> <p>Create a standardized workflow and set of scripts to prepare usage data (chats, codebase) for Fine-Tuning (LoRA). This is the first step towards a self-improving agent that learns from the user's specific coding style and project context.</p>"},{"location":"features/10_fine_tuning_pipeline/#2-requirements","title":"2. Requirements","text":"<p>List specific, testable requirements: - [x] Implement <code>scripts/export_chat_logs.py</code>: Export Open WebUI chat history to JSONL. - [x] Implement <code>scripts/prepare_dataset.py</code>: Format data for Unsloth or similar trainers. - [x] Format: Output standard ShareGPT or Alpaca format JSONL.</p>"},{"location":"features/10_fine_tuning_pipeline/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: Create <code>scripts/finetune/</code>.</li> <li>Dependencies: <code>pandas</code>, <code>sqlitedict</code> (to read WebUI DB if needed).</li> <li>Data: Output datasets in <code>data/datasets/</code>.</li> </ul>"},{"location":"features/10_fine_tuning_pipeline/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Script/Test: Run export script, verify JSONL validity.</p> <p>Manual Verification: - [x] Step 1: Accumulate some chat history. - [x] Step 2: Run export script. - [x] Step 3: Inspect output JSONL for correctness.</p>"},{"location":"features/10_fine_tuning_pipeline/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<p>Follow the AI Behavior strict workflow: - [x] Branch: Created <code>feat/finetune-pipeline</code> branch? - [x] Work: Implemented changes? - [x] Test: All tests pass? - [x] Doc: Updated <code>README.md</code>? - [x] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>?</p>"},{"location":"features/11_scheduled_tasks/","title":"Feature: Scheduled Tasks &amp; Reporting","text":""},{"location":"features/11_scheduled_tasks/#goal","title":"Goal","text":"<p>Enable users to define automated, recurring tasks (prompts) that execute on a schedule and deliver results via email.</p>"},{"location":"features/11_scheduled_tasks/#user-stories","title":"User Stories","text":"<ul> <li>As a user, I want to tell the system \"Send me a summary of the latest AI news every morning at 8 AM\" and have it happen automatically.</li> <li>As a user, I want to define a specific prompt (e.g., \"Analyze my daily logs\") and have the report emailed to me.</li> <li>As a user, I want to list and cancel active scheduled tasks.</li> </ul>"},{"location":"features/11_scheduled_tasks/#technical-components","title":"Technical Components","text":""},{"location":"features/11_scheduled_tasks/#1-scheduler-engine","title":"1. Scheduler Engine","text":"<ul> <li>Library: <code>APScheduler</code> (Advanced Python Scheduler).</li> <li>Location: Integrated into <code>blackbox-mcp</code> (MCP Server).</li> <li>Persistence: SQLite database (<code>scheduler.db</code>) to persist jobs across restarts.</li> </ul>"},{"location":"features/11_scheduled_tasks/#2-mcp-tools","title":"2. MCP Tools","text":"<p>The scheduler will be exposed via MCP tools, utilizing the Agentic interface: - <code>schedule_task(title, prompt, schedule_cron, recipients)</code>: Creates a new job. - <code>list_tasks()</code>: Returns all active jobs. - <code>delete_task(job_id)</code>: Removes a scheduled job.</p>"},{"location":"features/11_scheduled_tasks/#3-execution-logic","title":"3. Execution Logic","text":"<ul> <li>When a job triggers:<ol> <li>Generate: The MCP server calls the LLM (Ollama or OpenAI API) with the user's prompt.</li> <li>Format: The result is formatted into a report (Markdown/HTML).</li> <li>Deliver: The report is emailed to the specified recipients.</li> </ol> </li> </ul>"},{"location":"features/11_scheduled_tasks/#4-configuration","title":"4. Configuration","text":"<p>New environment variables in <code>docker-compose.yml</code>: - <code>SMTP_HOST</code>: Mail server host (e.g., <code>smtp.gmail.com</code>). - <code>SMTP_PORT</code>: Mail server port (e.g., <code>587</code>). - <code>SMTP_USER</code>: Mail user. - <code>SMTP_PASS</code>: Mail password (app password). - <code>EMAIL_FROM</code>: Sender address.</p>"},{"location":"features/11_scheduled_tasks/#data-flow","title":"Data Flow","text":"<p>User -&gt; \"Schedule task...\" -&gt; LLM -&gt; <code>schedule_task</code> Tool -&gt; <code>APScheduler</code> (persists to DB). ...[Time Passes]... <code>APScheduler</code> -&gt; Triggers Job -&gt; Calls LLM Configured -&gt; Generates Content -&gt; Sends Email.</p>"},{"location":"features/12_scheduler_dashboard/","title":"Feature: Scheduler Dashboard","text":""},{"location":"features/12_scheduler_dashboard/#goal","title":"Goal","text":"<p>Provide a graphical user interface (GUI) for users to manage Scheduled Tasks (Add, List, Edit, Delete) without using chat commands.</p>"},{"location":"features/12_scheduler_dashboard/#constraints","title":"Constraints","text":"<ul> <li>Open WebUI does not natively support adding custom links/views to the sidebar.</li> <li>Solution: We will host a standalone dashboard on the MCP Server (<code>http://localhost:8000/dashboard</code>) which runs alongside Open WebUI.</li> </ul>"},{"location":"features/12_scheduler_dashboard/#user-stories","title":"User Stories","text":"<ul> <li>As a user, I want to see a list of all active scheduled jobs with their next run times.</li> <li>As a user, I want a form to easily create a new task (Title, Prompt, Schedule, Recipients).</li> <li>As a user, I want to manually trigger a task immediately to verify it works (\"Run Now\").</li> </ul>"},{"location":"features/12_scheduler_dashboard/#technical-components","title":"Technical Components","text":""},{"location":"features/12_scheduler_dashboard/#1-backend-mcp-server","title":"1. Backend (MCP Server)","text":"<ul> <li>Framework: <code>FastAPI</code> (exposed via <code>mcp.sse_app()</code>).</li> <li>Static Files: Mount a <code>/static</code> directory to serve the frontend.</li> <li>API Endpoints:<ul> <li><code>GET /api/tasks</code>: List tasks (JSON).</li> <li><code>POST /api/tasks</code>: Create task.</li> <li><code>DELETE /api/tasks/{job_id}</code>: Delete task.</li> <li><code>POST /api/tasks/{job_id}/run</code>: Manually trigger task.</li> <li>Note: These endpoints will reuse the logic from <code>scheduler.py</code>.</li> </ul> </li> </ul>"},{"location":"features/12_scheduler_dashboard/#2-frontend","title":"2. Frontend","text":"<ul> <li>Technology: Vanilla HTML/JS/CSS (keep it lightweight and dependency-free).</li> <li>Design: Dark mode to match Open WebUI aesthetics.</li> <li>Location: <code>mcp_server/static/</code><ul> <li><code>index.html</code>: The main view.</li> <li><code>app.js</code>: Logic for fetching data and handling form submissions.</li> <li><code>style.css</code>: Styling.</li> </ul> </li> </ul>"},{"location":"features/12_scheduler_dashboard/#data-flow","title":"Data Flow","text":"<p>Browser -&gt; <code>GET /dashboard</code> -&gt; Loads HTML/JS. Browser -&gt; <code>GET /api/tasks</code> -&gt; <code>TaskScheduler.list_tasks()</code> -&gt; JSON Response. Browser -&gt; <code>POST /api/tasks</code> -&gt; <code>TaskScheduler.add_task()</code> -&gt; Database Update.</p>"},{"location":"features/13_nebulus_manager/","title":"Feature: Nebulus Manager CLI","text":""},{"location":"features/13_nebulus_manager/#1-overview","title":"1. Overview","text":"<p>Branch: <code>feat/nebulus-manager</code></p> <p>Build a unified \"Nebulus Manager\" CLI to manage containers, check logs, and monitor the AI instance from a terminal. This tool consolidates existing utility scripts and provides a rich, user-friendly interface for ecosystem management.</p>"},{"location":"features/13_nebulus_manager/#2-requirements","title":"2. Requirements","text":"<ul> <li>[ ] Service Management: Start (<code>up</code>), Stop (<code>down</code>), and Restart services via Docker Compose.</li> <li>[ ] Status Dashboard: A rich visual display of current service health (replacing/enhancing <code>scripts/health.sh</code>).</li> <li>[ ] Log Streaming: Stream aggregated or service-specific logs.</li> <li>[ ] Maintenance: Quick commands for <code>backup</code> and <code>restore</code> (wrappers for existing scripts).</li> <li>[ ] Monitoring: Command to launch Dozzle (log viewer) in the default browser.</li> <li>[ ] Interactive Shell: Capability to drop into a container's shell.</li> <li>[ ] Testing: Full unit test coverage for CLI logic.</li> </ul>"},{"location":"features/13_nebulus_manager/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules: <code>nebulus</code> (Main CLI script), <code>mcp_server/scheduler.py</code> (referenced).</li> <li>Dependencies: <code>click</code>, <code>rich</code>.</li> <li>Data: None (stateless CLI).</li> </ul>"},{"location":"features/13_nebulus_manager/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [ ] <code>pytest tests/test_nebulus_cli.py</code>: Verify command parsing and subprocess execution logic. - [ ] <code>flake8 nebulus</code>: Ensure linting compliance.</p> <p>Manual Verification: - [ ] Run <code>./nebulus status</code> and verify the table displays correctly. - [ ] Run <code>./nebulus monitor</code> and verify the browser opens to the correct port. - [ ] Run <code>./nebulus up</code> and verify containers start.</p>"},{"location":"features/13_nebulus_manager/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<ul> <li>[ ] Branch: Created <code>feat/nebulus-manager</code> branch?</li> <li>[ ] Work: Implemented changes (code, type hints, docstrings)?</li> <li>[ ] Test: All tests pass (<code>pytest</code>, <code>flake8</code>)?</li> <li>[ ] Doc: Updated <code>README.md</code> and created <code>walkthrough.md</code>?</li> <li>[ ] Data: Committed and pushed to origin?</li> </ul>"},{"location":"features/setup_blackbox_scaffolding/","title":"Feature: Black Box System Scaffolding","text":""},{"location":"features/setup_blackbox_scaffolding/#1-overview","title":"1. Overview","text":"<p>Branch: <code>develop</code></p> <p>Scaffold the initial \"Black Box\" AI system using Docker. This setup integrates Ollama (backend), Open WebUI (frontend), ChromaDB (RAG), and a custom MCP Server (tools) into a unified local stack.</p>"},{"location":"features/setup_blackbox_scaffolding/#2-requirements","title":"2. Requirements","text":"<ul> <li>[x] Create <code>docker-compose.yml</code> orchestrating Ollama, WebUI, ChromaDB, and MCP.</li> <li>[x] Configure internal Docker network <code>ai-network</code>.</li> <li>[x] Implement custom MCP server in Python with file system and web search tools.</li> <li>[x] Enable persistent storage for vector DB and model files.</li> <li>[x] Document setup instructions in <code>README.md</code>.</li> </ul>"},{"location":"features/setup_blackbox_scaffolding/#3-technical-implementation","title":"3. Technical Implementation","text":"<ul> <li>Modules:<ul> <li><code>docker-compose.yml</code>: Main orchestration file.</li> <li><code>mcp_server/</code>: New directory for the MCP tool service.</li> <li><code>mcp_server/server.py</code>: FastAPI/FastMCP implementation.</li> <li><code>mcp_server/Dockerfile</code>: Container definition.</li> </ul> </li> <li>Dependencies:<ul> <li><code>fastapi</code>, <code>uvicorn</code>, <code>mcp</code>, <code>duckduckgo-search</code> (inside MCP container).</li> </ul> </li> <li>Configuration:<ul> <li><code>.env.example</code>: Template for secrets and URLs.</li> </ul> </li> </ul>"},{"location":"features/setup_blackbox_scaffolding/#4-verification-plan","title":"4. Verification Plan","text":"<p>Automated Tests: - [x] Docker Config: <code>docker-compose config</code> passed.</p> <p>Manual Verification: - [x] Verified <code>docker-compose.yml</code> structure matches requirements. - [x] Verified MCP server code (<code>server.py</code>) contains requested tools (<code>list_directory</code>, <code>web_search</code>).</p>"},{"location":"features/setup_blackbox_scaffolding/#5-workflow-checklist","title":"5. Workflow Checklist","text":"<ul> <li>[x] Branch: Working on <code>develop</code>.</li> <li>[x] Work: Implemented Docker and Python files.</li> <li>[x] Test: Configuration validated.</li> <li>[x] Doc: Updated <code>README.md</code> and created <code>walkthrough.md</code>.</li> <li>[ ] Data: <code>git add .</code>, <code>git commit</code>, <code>git push</code>.</li> </ul>"},{"location":"troubleshooting/model_visibility/","title":"Troubleshooting: Open WebUI Model Visibility","text":""},{"location":"troubleshooting/model_visibility/#issue-description","title":"Issue Description","text":"<p>Users reported observing duplicate model names in the Open WebUI dropdown menu: both the \"Friendly Name\" (e.g., \"Llama 3.2 Vision\") and the \"Technical/Raw Name\" (e.g., <code>llama3.2-vision:latest</code>) were visible simultaneously. This occurred despite configuring \"Friendly Models\" in the database.</p>"},{"location":"troubleshooting/model_visibility/#root-causes","title":"Root Causes","text":""},{"location":"troubleshooting/model_visibility/#1-environment-variable-parsing-quoting","title":"1. Environment Variable Parsing (Quoting)","text":"<p>The <code>MODEL_FILTER_LIST</code> environment variable in <code>docker-compose.yml</code> was encapsulated in single quotes: <pre><code># Incorrect\nMODEL_FILTER_LIST='llama-3.2-vision;llama-3.1;qwen-2.5-coder'\n</code></pre> The Docker container environment treated the single quotes as part of the string value. Consequently, Open WebUI's filter logic failed to match the model IDs because it was looking for IDs starting or ending with a quote.</p>"},{"location":"troubleshooting/model_visibility/#2-database-hidden-models","title":"2. Database \"Hidden\" Models","text":"<p>We initially attempted to hide the raw models by inserting them into the <code>model</code> table with <code>is_active=0</code>. However, explicitly registering a raw model ID (e.g., <code>llama3.2-vision:latest</code>) in the <code>model</code> table causes Open WebUI to treat it as a Custom Model. Even if inactive, it seemingly interfered with the dynamic model discovery filtering logic, or the system forced it to be available because it was explicitly defined.</p>"},{"location":"troubleshooting/model_visibility/#3-default-model-configuration","title":"3. Default Model Configuration","text":"<p>The <code>DEFAULT_MODELS</code> environment variable was set to the raw ID <code>llama3.2-vision:latest</code>. Open WebUI ensures the default model is always available in the list, potentially overriding filter settings.</p>"},{"location":"troubleshooting/model_visibility/#4-admin-access-control","title":"4. Admin Access Control","text":"<p>By default, <code>BYPASS_ADMIN_ACCESS_CONTROL</code> is set to <code>true</code>. This grants administrators access to all models, bypassing the whitelist filter (<code>ENABLE_MODEL_FILTER</code>).</p>"},{"location":"troubleshooting/model_visibility/#solution","title":"Solution","text":""},{"location":"troubleshooting/model_visibility/#1-correct-environment-variables","title":"1. Correct Environment Variables","text":"<p>We updated <code>docker-compose.yml</code> to remove quotes and ensure strict boolean formatting: <pre><code># Correct\nBYPASS_ADMIN_ACCESS_CONTROL=false\nENABLE_MODEL_FILTER=true\nMODEL_FILTER_LIST=llama-3.2-vision;llama-3.1;qwen-2.5-coder\nDEFAULT_MODELS=llama-3.2-vision\n</code></pre></p>"},{"location":"troubleshooting/model_visibility/#2-database-cleanup","title":"2. Database Cleanup","text":"<p>We modified the <code>scripts/configure_friendly_models.py</code> script to delete the raw model entries from the database instead of marking them as inactive. This removes them from the \"Custom Model\" registry, allowing the <code>ENABLE_MODEL_FILTER</code> whitelist to correctly filter the dynamically discovered Ollama models.</p>"},{"location":"troubleshooting/model_visibility/#3-friendly-default-model","title":"3. Friendly Default Model","text":"<p>We updated <code>DEFAULT_MODELS</code> to use the friendly ID (<code>llama-3.2-vision</code>), ensuring the default selection aligns with the whitelisted items.</p>"},{"location":"troubleshooting/model_visibility/#verification","title":"Verification","text":"<p>After applying these changes and recreating the container, only the friendly model names are visible in the dropdown for both admin and regular users.</p>"}]}